#!/usr/bin/env python3
"""
NFSR Cycle Calculator

This program calculates all cycles generated by a Nonlinear Feedback Shift Register (NFSR).
It allows users to define an NFSR with a custom feedback function and register length,
then computes and displays all cycles.
"""

import itertools
from typing import List, Dict, Tuple, Callable, Set
import time

# Import example feedback functions if available
try:
    from example_feedback_functions import functions as example_functions
    HAS_EXAMPLE_FUNCTIONS = True
except ImportError:
    HAS_EXAMPLE_FUNCTIONS = False


class NFSRCycleCalculator:
    """Calculator for NFSR cycles."""
    
    def __init__(self, register_length: int, feedback_function: Callable[[List[int]], int]):
        """
        Initialize the NFSR cycle calculator.
        
        Args:
            register_length: Length of the register in bits
            feedback_function: Function that takes the current register state and returns the next input bit
        """
        self.register_length = register_length
        self.feedback_function = feedback_function
        self.max_states = 2 ** register_length
        
    def state_to_int(self, state: List[int]) -> int:
        """Convert a binary state list to an integer."""
        return int(''.join(map(str, state)), 2)
    
    def int_to_state(self, value: int) -> List[int]:
        """Convert an integer to a binary state list of the correct length."""
        binary = bin(value)[2:].zfill(self.register_length)
        return [int(bit) for bit in binary]
    
    def next_state(self, current_state: List[int]) -> List[int]:
        """Calculate the next state of the register based on the feedback function."""
        feedback_bit = self.feedback_function(current_state)
        new_state = current_state[1:] + [feedback_bit]
        return new_state
    
    def find_cycle(self, start_state: List[int]) -> Tuple[List[List[int]], int]:
        """
        Find the cycle starting from a given state.
        
        Returns:
            Tuple of (cycle states, cycle length)
        """
        current_state = start_state.copy()
        visited_states = {}
        sequence = []
        
        step = 0
        while True:
            state_int = self.state_to_int(current_state)
            
            # If we've seen this state before, we've found a cycle
            if state_int in visited_states:
                cycle_start = visited_states[state_int]
                cycle_length = step - cycle_start
                cycle_states = sequence[cycle_start:step]
                return cycle_states, cycle_length
            
            # Record this state
            visited_states[state_int] = step
            sequence.append(current_state.copy())
            
            # Move to the next state
            current_state = self.next_state(current_state)
            step += 1
    
    def find_all_cycles(self) -> Dict[int, List[List[int]]]:
        """
        Find all unique cycles in the NFSR.
        
        Returns:
            Dictionary mapping cycle length to list of cycles
        """
        cycles = {}
        visited = set()
        
        for i in range(self.max_states):
            if i in visited:
                continue
                
            start_state = self.int_to_state(i)
            cycle_states, cycle_length = self.find_cycle(start_state)
            
            # Add all states in this cycle to visited
            for state in cycle_states:
                visited.add(self.state_to_int(state))
            
            # Store the cycle
            if cycle_length not in cycles:
                cycles[cycle_length] = []
            cycles[cycle_length].append(cycle_states)
        
        return cycles
    
    def display_cycles(self, cycles: Dict[int, List[List[int]]]):
        """Display all cycles in a readable format."""
        total_cycles = sum(len(cycle_list) for cycle_list in cycles.values())
        
        print(f"\nNFSR with register length {self.register_length}")
        print(f"Found {total_cycles} unique cycles:\n")
        
        for length, cycle_list in sorted(cycles.items()):
            print(f"Cycles of length {length}: {len(cycle_list)}")
            
            for i, cycle in enumerate(cycle_list, 1):
                if len(cycle_list) <= 10 or i <= 3:  # Only show details for up to 3 cycles if there are many
                    print(f"  Cycle {i}:")
                    for state in cycle:
                        print(f"    {''.join(map(str, state))}")
            
            if len(cycle_list) > 10:
                print(f"  ... and {len(cycle_list) - 3} more cycles of length {length}")
            print()

    def calculate_cycle_distribution(self, cycles: Dict[int, List[List[int]]]):
        """Calculate and display statistics about the cycle distribution."""
        print("\nCycle Distribution Statistics:")
        print("-" * 30)
        
        total_states = 0
        total_cycles = 0
        
        for length, cycle_list in sorted(cycles.items()):
            num_cycles = len(cycle_list)
            states_count = length * num_cycles
            total_states += states_count
            total_cycles += num_cycles
            
            print(f"Length {length}: {num_cycles} cycles ({states_count} states)")
        
        print("-" * 30)
        print(f"Total: {total_cycles} cycles ({total_states} states out of {self.max_states} possible)")
        
        # Verify that all states are accounted for
        assert total_states == self.max_states, f"Error: Only found {total_states} states out of {self.max_states}"

    def save_cycles_to_file(self, cycles: Dict[int, List[List[int]]], filename: str = "nfsr_cycles.txt"):
        """Save all cycle information to a file."""
        with open(filename, 'w') as f:
            f.write(f"NFSR Cycle Analysis\n")
            f.write(f"Register length: {self.register_length}\n")
            
            total_cycles = sum(len(cycle_list) for cycle_list in cycles.values())
            f.write(f"Total unique cycles: {total_cycles}\n\n")
            
            for length, cycle_list in sorted(cycles.items()):
                f.write(f"Cycles of length {length}: {len(cycle_list)}\n")
                
                for i, cycle in enumerate(cycle_list, 1):
                    f.write(f"  Cycle {i}:\n")
                    for state in cycle:
                        f.write(f"    {''.join(map(str, state))}\n")
                f.write("\n")
            
            # Write distribution statistics
            f.write("Cycle Distribution Statistics:\n")
            f.write("-" * 30 + "\n")
            
            total_states = 0
            total_cycles = 0
            
            for length, cycle_list in sorted(cycles.items()):
                num_cycles = len(cycle_list)
                states_count = length * num_cycles
                total_states += states_count
                total_cycles += num_cycles
                
                f.write(f"Length {length}: {num_cycles} cycles ({states_count} states)\n")
            
            f.write("-" * 30 + "\n")
            f.write(f"Total: {total_cycles} cycles ({total_states} states out of {self.max_states} possible)\n")
        
        print(f"\nCycle information saved to {filename}")


# Example usage and predefined feedback functions

def example_feedback_function(state: List[int]) -> int:
    """
    Example nonlinear feedback function.
    This implements: f(x) = x[0] ⊕ (x[1] AND x[2])
    """
    return (state[0] ^ (state[1] & state[2])) % 2

def fibonacci_feedback(state: List[int]) -> int:
    """
    Fibonacci LFSR feedback function (linear): x[0] ⊕ x[1]
    """
    return (state[0] ^ state[1]) % 2

def create_custom_feedback_function(expression: str, register_length: int) -> Callable[[List[int]], int]:
    """
    Create a feedback function from a string expression.
    
    Example expression: "x[0] ^ (x[1] & x[2])"
    
    The expression should use:
    - x[i] for the i-th bit of the register
    - ^ for XOR
    - & for AND
    - | for OR
    - ~ for NOT
    """
    # Create a function that evaluates the expression
    def feedback_function(state: List[int]) -> int:
        # Create a dictionary mapping x[i] to the corresponding bit
        x = {f"x[{i}]": state[i] for i in range(register_length)}
        
        # Replace operators with Python operators
        expr = expression
        expr = expr.replace("^", " ^ ")
        expr = expr.replace("&", " & ")
        expr = expr.replace("|", " | ")
        expr = expr.replace("~", " ~ ")
        
        # Replace x[i] with the actual values
        for i in range(register_length):
            expr = expr.replace(f"x[{i}]", str(state[i]))
        
        # Evaluate the expression
        result = eval(expr)
        return result % 2
    
    return feedback_function


def main():
    print("=" * 60)
    print("NFSR Cycle Calculator")
    print("=" * 60)
    
    # Get user input for NFSR parameters
    while True:
        try:
            register_length = int(input("\nEnter register length (1-20): "))
            if register_length < 1 or register_length > 20:
                print("Register length must be between 1 and 20.")
                continue
            break
        except ValueError:
            print("Please enter a valid integer.")
    
    # Define available feedback function options
    menu_options = [
        "Predefined example: x[0] ⊕ (x[1] AND x[2])",
        "Fibonacci LFSR: x[0] ⊕ x[1]",
        "Custom feedback function"
    ]
    
    # Add example functions from the imported module if available
    if HAS_EXAMPLE_FUNCTIONS:
        for name in example_functions.keys():
            menu_options.append(f"Example: {name}")
    
    print("\nSelect feedback function type:")
    for i, option in enumerate(menu_options, 1):
        print(f"{i}. {option}")
    
    while True:
        try:
            function_choice = int(input(f"\nEnter your choice (1-{len(menu_options)}): "))
            if function_choice < 1 or function_choice > len(menu_options):
                print(f"Please enter a number between 1 and {len(menu_options)}.")
                continue
            break
        except ValueError:
            print("Please enter a valid integer.")
    
    if function_choice == 1:
        feedback_function = example_feedback_function
        print("\nUsing predefined example feedback function: x[0] ⊕ (x[1] AND x[2])")
    elif function_choice == 2:
        feedback_function = fibonacci_feedback
        print("\nUsing Fibonacci LFSR feedback function: x[0] ⊕ x[1]")
    elif function_choice == 3:
        print("\nEnter your custom feedback function using Python syntax.")
        print("Use x[i] to refer to the i-th bit of the register (0-indexed).")
        print("Example: x[0] ^ (x[1] & x[2])")
        expression = input("\nFeedback function: ")
        feedback_function = create_custom_feedback_function(expression, register_length)
    else:
        # User selected one of the example functions
        example_index = function_choice - 4  # Adjust for the first 3 options
        function_name = list(example_functions.keys())[example_index]
        feedback_function = example_functions[function_name]
        print(f"\nUsing example feedback function: {function_name}")
    
    # Ask if user wants to save results to file
    save_to_file = input("\nDo you want to save results to a file? (y/n): ").lower().startswith('y')
    
    # Create calculator and find cycles
    print("\nCalculating cycles...")
    start_time = time.time()
    
    calculator = NFSRCycleCalculator(register_length, feedback_function)
    cycles = calculator.find_all_cycles()
    
    end_time = time.time()
    calculation_time = end_time - start_time
    
    # Display results
    calculator.display_cycles(cycles)
    calculator.calculate_cycle_distribution(cycles)
    
    # Save to file if requested
    if save_to_file:
        filename = input("\nEnter filename (default: nfsr_cycles.txt): ") or "nfsr_cycles.txt"
        calculator.save_cycles_to_file(cycles, filename)
    
    print(f"\nCalculation completed in {calculation_time:.4f} seconds")


if __name__ == "__main__":
    main() 