#!/usr/bin/env python3
"""
NFSR Cycle Calculator

This program calculates all cycles generated by a Nonlinear Feedback Shift Register (NFSR).
It allows users to define an NFSR with a custom feedback function and register length,
then computes and displays all cycles.
"""

import itertools
from typing import List, Dict, Tuple, Callable, Set
import time

# Import example feedback function s if available
#try:
#    from example_feedback_functions import functions as example_functions
#    HAS_EXAMPLE_FUNCTIONS = True
#except ImportError:
#    HAS_EXAMPLE_FUNCTIONS = False


class NFSRCycleCalculator:
    """Calculator for NFSR cycles."""
    
    def __init__(self, register_length: int, feedback_function: Callable[[List[int]], int]):
        """
        Initialize the NFSR cycle calculator.
        
        Args:
            register_length: Length of the register in bits
            feedback_function: Function that takes the current register state and returns the next input bit
        """
        self.register_length = register_length
        self.feedback_function = feedback_function
        self.max_states = 2 ** register_length
        
    def state_to_int(self, state: List[int]) -> int:
        """Convert a binary state list to an integer."""
        return int(''.join(map(str, state)), 2)
    
    def int_to_state(self, value: int) -> List[int]:
        """Convert an integer to a binary state list of the correct length."""
        binary = bin(value)[2:].zfill(self.register_length)
        return [int(bit) for bit in binary]
    
    def next_state(self, current_state: List[int]) -> List[int]:
        """Calculate the next state of the register based on the feedback function."""
        feedback_bit = self.feedback_function(current_state)
        new_state = current_state[1:] + [feedback_bit]
        return new_state
    
    def find_cycle(self, start_state: List[int]) -> Tuple[List[List[int]], int]:
        """
        Find the cycle starting from a given state.
        
        Returns:
            Tuple of (cycle states, cycle length)
        """
        current_state = start_state.copy()
        visited_states = {}
        sequence = []
        
        step = 0
        while True:
            state_int = self.state_to_int(current_state)
            
            # If we've seen this state before, we've found a cycle
            if state_int in visited_states:
                cycle_start = visited_states[state_int]
                cycle_length = step - cycle_start
                cycle_states = sequence[cycle_start:step]
                return cycle_states, cycle_length
            
            # Record this state
            visited_states[state_int] = step
            sequence.append(current_state.copy())
            
            # Move to the next state
            current_state = self.next_state(current_state)
            step += 1
    
    def find_all_cycles(self) -> Dict[int, List[List[int]]]:
        """
        Find all unique cycles in the NFSR.
        
        Returns:
            Dictionary mapping cycle length to list of cycles
        """
        cycles = {}
        visited = set()
        
        for i in range(self.max_states):
            if i in visited:
                continue
                
            start_state = self.int_to_state(i)
            cycle_states, cycle_length = self.find_cycle(start_state)
            
            # Add all states in this cycle to visited
            for state in cycle_states:
                visited.add(self.state_to_int(state))
            
            # Store the cycle
            if cycle_length not in cycles:
                cycles[cycle_length] = []
            cycles[cycle_length].append(cycle_states)
        
        return cycles
    
    def display_cycles(self, cycles: Dict[int, List[List[int]]]):
        """Display all cycles in a readable format."""
        total_cycles = sum(len(cycle_list) for cycle_list in cycles.values())
        
        print(f"\nNFSR with register length {self.register_length}")
        print(f"Found {total_cycles} unique cycles:\n")
        
        for length, cycle_list in sorted(cycles.items()):
            print(f"Cycles of length {length}: {len(cycle_list)}")
            
            for i, cycle in enumerate(cycle_list, 1):
                if len(cycle_list) <= 10 or i <= 3:  # Only show details for up to 3 cycles if there are many
                    print(f"  Cycle {i}:", end=" ")
                    # Display states in a line with -> between them
                    states = [f"{''.join(map(str, state))}" for state in cycle]
                    # Add the first state again at the end to show the cycle completion
                    states.append(states[0])
                    print(" -> ".join(states))
            
            if len(cycle_list) > 10:
                print(f"  ... and {len(cycle_list) - 3} more cycles of length {length}")
            print()

    def calculate_cycle_distribution(self, cycles: Dict[int, List[List[int]]]):
        """Calculate and display statistics about the cycle distribution."""
        print("\nCycle Distribution Statistics:")
        print("-" * 30)
        
        total_states = 0
        total_cycles = 0
        
        for length, cycle_list in sorted(cycles.items()):
            num_cycles = len(cycle_list)
            states_count = length * num_cycles
            total_states += states_count
            total_cycles += num_cycles
            
            print(f"Length {length}: {num_cycles} cycles ({states_count} states)")
        
        print("-" * 30)
        print(f"Total: {total_cycles} cycles ({total_states} states out of {self.max_states} possible)")
        
        # Verify that all states are accounted for
        assert total_states == self.max_states, f"Error: Only found {total_states} states out of {self.max_states}"

    def save_cycles_to_file(self, cycles: Dict[int, List[List[int]]], filename: str = "nfsr_cycles.txt"):
        """Save all cycle information to a file with progress feedback."""
        total_cycle_lengths = len(cycles)
        print(f"\nSaving cycle information to {filename}...")
        print(f"Writing data for {total_cycle_lengths} different cycle lengths...")
        
        with open(filename, 'w') as f:
            f.write(f"NFSR Cycle Analysis\n")
            f.write(f"Register length: {self.register_length}\n")
            
            total_cycles = sum(len(cycle_list) for cycle_list in cycles.values())
            f.write(f"Total unique cycles: {total_cycles}\n\n")
            print(f"Writing header information... ✓")
            
            for i, (length, cycle_list) in enumerate(sorted(cycles.items()), 1):
                f.write(f"Cycles of length {length}: {len(cycle_list)}\n")
                print(f"Writing cycles of length {length} ({len(cycle_list)} cycles)... ", end='', flush=True)
                
                for j, cycle in enumerate(cycle_list, 1):
                    f.write(f"  Cycle {j}: ")
                    states = [f"{''.join(map(str, state))}" for state in cycle]
                    states.append(states[0])
                    f.write(" -> ".join(states) + "\n")
                f.write("\n")
                print("✓")
            
            print("Writing distribution statistics... ", end='', flush=True)
            f.write("Cycle Distribution Statistics:\n")
            f.write("-" * 30 + "\n")
            
            total_states = 0
            total_cycles = 0
            
            for length, cycle_list in sorted(cycles.items()):
                num_cycles = len(cycle_list)
                states_count = length * num_cycles
                total_states += states_count
                total_cycles += num_cycles
                
                f.write(f"Length {length}: {num_cycles} cycles ({states_count} states)\n")
            
            f.write("-" * 30 + "\n")
            f.write(f"Total: {total_cycles} cycles ({total_states} states out of {self.max_states} possible)\n")
            print("✓")
        
        print(f"\nFile saved successfully to {filename} ✓")


# Example usage and predefined feedback functions

def example_feedback_function(state: List[int]) -> int:
    """
    Example nonlinear feedback function.
    This implements: f(x) = x[0] ⊕ (x[1] AND x[2])
    """
    return (state[0] ^ (state[1] & state[2])) % 2

def fibonacci_feedback(state: List[int]) -> int:
    """
    Fibonacci LFSR feedback function (linear): x[0] ⊕ x[1]
    """
    return (state[0] ^ state[1]) % 2

def create_custom_feedback_function(expression: str, register_length: int) -> Callable[[List[int]], int]:
    """
    Create a feedback function from a string expression.
    
    Example expression: "x[0] ^ (x[1] & x[2])"
    
    The expression should use:
    - x[i] for the i-th bit of the register
    - ^ for XOR
    - & for AND
    - | for OR
    - ~ for NOT
    """
    # Create a function that evaluates the expression
    def feedback_function(state: List[int]) -> int:
        # Create a dictionary mapping x[i] to the corresponding bit
        x = {f"x[{i}]": state[i] for i in range(register_length)}
        
        # Replace operators with Python operators
        expr = expression
        expr = expr.replace("^", " ^ ")
        expr = expr.replace("&", " & ")
        expr = expr.replace("|", " | ")
        expr = expr.replace("~", " ~ ")
        
        # Replace x[i] with the actual values
        for i in range(register_length):
            expr = expr.replace(f"x[{i}]", str(state[i]))
        
        # Evaluate the expression
        result = eval(expr)
        return result % 2
    
    return feedback_function

def parse_feedback_expression(expression: str, register_length: int) -> Callable[[List[int]], int]:
    """
    Parse a feedback function from a string expression in the format x0+x1*x2.
    
    This format uses:
    - x0, x1, x2, etc. to refer to the bits of the register
    - + for XOR operations
    - * for AND operations
    - * has higher priority than + in calculations
    
    Example: "x0+x1*x2+x2*x3" means x[0] ⊕ (x[1] & x[2]) ⊕ (x[2] & x[3])
    
    Args:
        expression: The expression string in the format x0+x1*x2
        register_length: Length of the register
        
    Returns:
        A function that takes a state and returns the feedback bit
    """
    # Create a function that evaluates the expression
    def feedback_function(state: List[int]) -> int:
        # Convert expression to Python syntax (x0 -> x[0], + -> ^, * -> &)
        expr = expression
        
        # Convert xN to state[N] for all possible register bits
        for i in range(register_length):
            expr = expr.replace(f"x{i}", f"state[{i}]")
        
        # Replace operators (+ -> ^ for XOR, * -> & for AND)
        expr = expr.replace("+", " ^ ")
        expr = expr.replace("*", " & ")
        
        # Evaluate the expression
        result = eval(expr)
        return result % 2
    
    return feedback_function


def main():
    print("=" * 60)
    print("NFSR Cycle Calculator")
    print("=" * 60)
    
    # Get user input for NFSR parameters
    while True:
        try:
            register_length = int(input("\nEnter register length (1-20): "))
            if register_length < 1 or register_length > 20:
                print("Register length must be between 1 and 20.")
                continue
            break
        except ValueError:
            print("Please enter a valid integer.")
    
    # Get feedback function directly from user
    print("\nEnter your feedback function in the format: x0+x1*x2")
    print("Use + for XOR operations and * for AND operations")
    print("Example: x0+x1*x2+x2*x3 means x[0] ⊕ (x[1] & x[2]) ⊕ (x[2] & x[3])")
    
    expression = input("\nFeedback function: ")
    feedback_function = parse_feedback_expression(expression, register_length)
    
    # Ask if user wants to save results to file
    save_to_file = input("\nDo you want to save results to a file? (y/n): ").lower().startswith('y')
    
    # Create calculator and find cycles
    print("\nCalculating cycles...")
    start_time = time.time()
    
    calculator = NFSRCycleCalculator(register_length, feedback_function)
    cycles = calculator.find_all_cycles()
    
    end_time = time.time()
    calculation_time = end_time - start_time
    
    # Display results
    calculator.display_cycles(cycles)
    calculator.calculate_cycle_distribution(cycles)
    
    # Save to file if requested
    if save_to_file:
        filename = input("\nEnter filename (default: nfsr_cycles.txt): ") or "nfsr_cycles.txt"
        calculator.save_cycles_to_file(cycles, filename)
    
    print(f"\nCalculation completed in {calculation_time:.4f} seconds")


if __name__ == "__main__":
    main() 